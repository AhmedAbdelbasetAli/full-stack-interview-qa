# üì¶ NoSQL Deep Dive (Part 5)  
**Redis Caching, TTL, Cassandra, Eventual Consistency & NoSQL Advantages**

This document covers **advanced NoSQL concepts** ‚Äî essential for **performance**, **scalability**, and **system design interviews**.

Each section includes:
- ‚úÖ Clear definition
- ‚úÖ In-depth explanation
- ‚úÖ Real-world examples
- ‚úÖ Best practices
- ‚úÖ Interview-ready answers

---

## 21. How is Redis used for caching?

> **Redis** is one of the **most popular caching solutions** due to its **in-memory speed**, **rich data structures**, and **TTL support**.

It‚Äôs used to **reduce database load** and **improve response times**.

---

### üîπ Common Caching Patterns

#### ‚úÖ 1. **Cache-Aside (Lazy Loading)**
```text
[App] ‚Üí Check Redis ‚Üí 
    ‚úÖ Hit: Return from cache
    ‚ùå Miss: Read DB ‚Üí Write to Redis ‚Üí Return
```

```java
public User getUser(Long id) {
    String key = "user:" + id;
    
    // Try cache first
    String cached = redis.get(key);
    if (cached != null) {
        return deserialize(cached);
    }

    // Cache miss: read from DB
    User user = userRepository.findById(id);
    if (user != null) {
        redis.setex(key, 3600, serialize(user)); // Cache for 1 hour
    }
    return user;
}
```

‚úÖ Most common pattern  
‚úÖ App controls cache lifecycle

---

#### ‚úÖ 2. **Write-Through**
```text
[App] ‚Üí Write to Redis ‚Üí Redis writes to DB ‚Üí Ack to App
```

‚úÖ Data always consistent  
‚úÖ Slower (writes go through Redis)

---

#### ‚úÖ 3. **Write-Behind (Write-Back)**
```text
[App] ‚Üí Write to Redis ‚Üí Redis queues DB write ‚Üí Async DB update
```

‚úÖ Fast writes  
‚úÖ Risk of data loss if Redis crashes before DB write

---

### üîπ Real-World Use Cases

| Use Case | How |
|--------|-----|
| ‚úÖ **Database Query Results** | Cache `getUserById`, `getProductCatalog` |
| ‚úÖ **Session Storage** | Store user session in Redis with TTL |
| ‚úÖ **Full Page Caching** | Cache HTML of popular pages |
| ‚úÖ **API Response Caching** | Cache `/api/users` response |
| ‚úÖ **Rate Limiting** | Track requests with `INCR` + `EXPIRE` |

---

### üîπ Best Practices

| Rule | Why |
|------|-----|
| ‚úÖ **Use appropriate TTL** | Prevent stale data, memory bloat |
| ‚úÖ **Handle cache misses gracefully** | Fall back to DB |
| ‚úÖ **Use cache stampede protection** | Add random TTL jitter to avoid mass expiry |
| ‚úÖ **Monitor hit rate** | Low hit rate ‚Üí reevaluate cache strategy |
| ‚úÖ **Use Redis Cluster** | For high availability and scalability |

---

### üìå Interview Answer

> _"I use Redis for caching with the cache-aside pattern: check Redis first, if miss, read DB and populate cache. I set TTL to avoid stale data. I cache database queries, sessions, and API responses. It reduces database load and improves latency from 100ms to 1ms."_  

---

## 22. What is TTL in Redis?

> **TTL (Time To Live)** is the **expiration time** for a Redis key ‚Äî after which it is **automatically deleted**.

It‚Äôs essential for **ephemeral data** like sessions, caches, and rate limits.

---

### ‚úÖ Commands

| Command | Purpose |
|--------|--------|
| `EXPIRE key 60` | Set TTL to 60 seconds |
| `EXPIREAT key 1672531200` | Expire at Unix timestamp |
| `TTL key` | Check remaining TTL (-1 = no TTL, -2 = expired) |
| `PERSIST key` | Remove TTL (make persistent) |
| `SET key value EX 3600` | Set with TTL in seconds |
| `SETEX key 3600 value` | Set + expire in one command |

---

### ‚úÖ Example: Session Management

```bash
# User logs in
SET session:abc123:user_id "123" EX 3600  # Expire in 1 hour

# Check session
TTL session:abc123:user_id  # Returns 3599, 3598, ...
# After 1 hour ‚Üí key gone
```

‚úÖ No cleanup job needed ‚Äî Redis auto-deletes.

---

### ‚úÖ Example: Rate Limiting

```bash
# On each request
INCR user:123:req_count
# Only set TTL if key is new (first request in window)
NX EX 60  # Expire in 60 seconds

# If req_count > 100 ‚Üí reject request
```

‚úÖ Simple, fast, self-cleaning.

---

### üîπ TTL Best Practices

| Rule | Why |
|------|-----|
| ‚úÖ **Set TTL on all cache keys** | Prevent memory leaks |
| ‚úÖ **Add jitter to TTL** | Avoid "thundering herd" when keys expire together |
| ‚úÖ **Use `EX` with `SET`** | Atomic set + expire |
| ‚úÖ **Monitor memory usage** | Use `INFO memory` |
| ‚úÖ **Use Redis eviction policies** | `volatile-lru`, `allkeys-lru` when full |

---

### üìå Interview Answer

> _"TTL sets an expiration time for a Redis key. I use it for sessions, caches, and rate limits. After TTL, Redis auto-deletes the key. I use EXPIRE or SETEX to set it. I add jitter to avoid mass expiry. It‚Äôs essential for managing ephemeral data and preventing memory bloat."_  

---

## 23. What is Cassandra? What are its key features?

> **Apache Cassandra** is a **highly scalable, distributed NoSQL database** designed for **high availability** and **no single point of failure**.

It‚Äôs used by **Netflix, Apple, Uber** for massive-scale applications.

---

### üîπ Key Features

| Feature | Description |
|--------|-------------|
| ‚úÖ **Masterless Architecture** | All nodes are equal ‚Äî no single point of failure |
| ‚úÖ **Linear Scalability** | Add nodes ‚Üí linear increase in throughput |
| ‚úÖ **High Write Throughput** | Optimized for fast writes (logging, IoT) |
| ‚úÖ **Tunable Consistency** | Choose consistency level per query (ONE, QUORUM, ALL) |
| ‚úÖ **Eventual Consistency** | AP in CAP theorem |
| ‚úÖ **Column-Family Data Model** | Wide-column store (like Bigtable) |
| ‚úÖ **Multi-Datacenter Replication** | Built-in support for geo-distribution |
| ‚úÖ **CQL (Cassandra Query Language)** | SQL-like syntax |

---

### üîπ Data Model: Wide-Column Store

```cql
-- Table: user_playback
-- Primary Key: (user_id, timestamp)
 user_id | timestamp           | video_id | duration
---------+---------------------+----------+----------
  123   | 2025-04-05 10:00:00 | V1       | 3600
  123   | 2025-04-05 10:01:00 | V2       | 1800
```

‚úÖ Efficient for time-series data  
‚úÖ Rows can have different columns

---

### üîπ Use Cases

| Use Case | Why Cassandra? |
|--------|---------------|
| ‚úÖ **Time-Series Data** | Sensor data, logs, metrics |
| ‚úÖ **Messaging Systems** | High write volume |
| ‚úÖ **Recommendation Engines** | Fast reads/writes |
| ‚úÖ **IoT Platforms** | Millions of devices writing data |
| ‚úÖ **Content Management** | Global content delivery |

---

### üìå Interview Answer

> _"Cassandra is a distributed, masterless NoSQL database built for high availability and scalability. It uses a wide-column model and is AP in CAP. I use it for time-series data, logging, and high-write systems like IoT. It scales linearly and supports multi-datacenter replication."_  

---

## 24. What is eventual consistency, and which NoSQL databases use it?

> **Eventual consistency** means that **if no new updates are made**, all reads will **eventually return the last updated value**.

It‚Äôs a **trade-off** to achieve **availability** and **partition tolerance** in distributed systems.

---

### üîπ How It Works

```
[Write to Node A] ‚Üí Replicated to B, C ‚Üí Eventually all agree
```

But during replication:
- A read to **Node B** might return **old data**
- After sync ‚Üí all nodes return new data

‚úÖ Acceptable for many apps: social feeds, catalogs, analytics

---

### üîπ NoSQL Databases That Use Eventual Consistency

| Database | Default Consistency Model |
|--------|--------------------------|
| ‚úÖ **Cassandra** | Eventual (tunable to strong) |
| ‚úÖ **DynamoDB** | Eventual (strong consistency optional) |
| ‚úÖ **Couchbase** | Eventual |
| ‚úÖ **Riak** | Eventual |
| ‚úÖ **Redis (replicated)** | Eventual (async replication) |
| ‚úÖ **MongoDB (multi-region)** | Eventual (unless strong read preference) |

> ‚ùå **MongoDB (single replica set)**: Strong consistency by default (reads from primary)

---

### üîπ Example: Social Media Post

1. User posts "Hello!" ‚Üí written to **US node**
2. Follower in **EU** reads from **EU replica** ‚Üí sees old feed
3. 500ms later ‚Üí replica syncs ‚Üí now sees post

‚úÖ Trade-off: **availability** over **immediate consistency**

---

### üîπ Benefits

| Benefit | Explanation |
|--------|-------------|
| ‚úÖ **High Availability** | All nodes accept reads/writes during network issues |
| ‚úÖ **Low Latency** | Read from nearest node, even if stale |
| ‚úÖ **Scalability** | No coordination needed for every write |

---

### üìå Interview Answer

> _"Eventual consistency means data will become consistent after updates stop. It's used in distributed NoSQL databases like Cassandra, DynamoDB, and Redis to ensure availability during network partitions. I use it for social feeds and catalogs where immediate consistency isn't critical. For banking, I use strong consistency."_  

---

## 25. What are the advantages of NoSQL over SQL?

| Advantage | Explanation | Example |
|----------|-------------|--------|
| ‚úÖ **Flexible Schema** | No rigid schema ‚Äî add fields without migrations | Add `preferences` to user without `ALTER TABLE` |
| ‚úÖ **Horizontal Scalability** | Scale out by adding more servers | Handle 1M requests/sec with sharding |
| ‚úÖ **High Performance** | Optimized for specific workloads (e.g., key-value, document) | Redis: 100K ops/sec in memory |
| ‚úÖ **Better for Unstructured Data** | JSON, logs, sensor data | Store nested user preferences in MongoDB |
| ‚úÖ **High Availability & Fault Tolerance** | Built-in replication, no single point of failure | Cassandra: all nodes equal |
| ‚úÖ **Developer Productivity** | JSON-native, maps to objects | No ORM mapping for MongoDB |
| ‚úÖ **Cost-Effective at Scale** | Use commodity hardware | Scale to petabytes cheaper than SQL |

---

### üîπ When NoSQL Shines

| Scenario | Why NoSQL Wins |
|--------|---------------|
| ‚ùå **Rapid Iteration** | No schema migrations |
| ‚ùå **Big Data** | Petabytes of logs, IoT data |
| ‚ùå **Global Apps** | Geo-distributed, low-latency access |
| ‚ùå **Real-Time Analytics** | Fast writes, aggregation |
| ‚ùå **High Write Throughput** | 10K+ writes/sec |

---

### üìå Interview Answer

> _"NoSQL offers flexible schema, horizontal scaling, and high performance for unstructured data. I use it when I need to scale rapidly, handle JSON natively, or support high write throughput. It's ideal for modern apps with evolving data models. But I still use SQL for complex transactions and strong consistency."_  

---

## ‚úÖ Final Tip

> üéØ In interviews, **combine concepts**:
> _"I use Redis for caching with TTL, MongoDB for flexible document storage, and Cassandra for high-write time-series data ‚Äî all eventually consistent for availability."_  

That shows **deep, integrated NoSQL knowledge**.

---

